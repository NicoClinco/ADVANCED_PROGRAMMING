#ifndef _QUADRATURE1DHPP_
#define _QUADRATURE1DHPP_

#include <boost/math/quadrature/gauss.hpp>
#include <boost/math/special_functions/legendre.hpp>
#include <boost/math/constants/constants.hpp>
#include <vector>
#include <numeric>
#include <cmath>

namespace Integrate_1D{

   /*
     GENERIC-PATTERN FOR THE QUADRATURE RULE:
     
    class <TYPE>Quadrature
    {
     - makeQuadWeights(startfrom,end)
     - makeQuadPnts(startfrom,end)
     - operator()(fun,startfrom,end)
    }

  
  
   All the classes <TYPE>Quadrature
   have two methods:

   -makeWeights()
   -makeQuadPnts()
  
    These two methods create the
    weights and the quadrature points
    in equispaced manner.

   The operator() is overloaded
   and is called in the interface class
   NumericalIntegration.

   Thus, if one wants to implement a specific quadrature rule,
   one has only to implement the weights and the points.

   NOTE:
    - For the Simpson-quadrature rule,N is 1/2
      of the effective intervals retained: see the
      function below for clarity.

  */


  

template<int N>
class SimpsonQuadrature
{
public:

  // Simpson Rule:
  // \int_{a}^{b} f(x) dx = h/3 f(a) + h/3 f(b) +
  //                       \sum_i (2/3h f(x_{2i}) +4/3h f(x_{2i-1}) 
  virtual std::vector<double> makeWeights(double a,double b)
  {
    double h = (b-a)/(2*N);
    std::vector<double> weighs(2*N+1,0.0);
    weighs[0] = h/3;
    weighs[2*N] = h/3;
    int count = 1;
    std::generate(weighs.begin()+1,weighs.end()-1,
		  [&count,h]{double _w_ = (count%2) == 0 ?  (2.0*h/3.0) :  (4.0*h/3.0); count++; return _w_;});
  
    return weighs;
  }
  virtual std::vector<double> makeQuadPnts(double a,double b)
  {
    double h = (b-a)/(2*N);
    std::vector<double> xp(2*N+1,0.0); // number of points equispaced
    double xi = a;
    std::generate(xp.begin()+1,xp.end(),[&xi,h](){return xi=xi+h;});
    return xp;
  }
  double operator()(std::function<double (double)> funToInt,double a,double b)
  {
    // Use the composite trapezoidal rule:
 
    // Divide the interval [a,b] in subintervals and obtain the quadrature points:
    std::vector<double> w_ = this->makeWeights(a,b);
    std::vector<double> qp_= this->makeQuadPnts(a,b);
    
    // Evaluate function in the quadrature points:
    std::vector<double> fxi(2*N+1);
    std::transform(qp_.begin(),qp_.end(),fxi.begin(),funToInt);

    // Return the inner product:
    return std::inner_product(w_.begin(),w_.end(),fxi.begin(),0.0);
  }
};


template<int N>
class TrapzQuadrature
{
public:

  virtual std::vector<double> makeWeights(double a,double b)
  {
    double h = (b-a)/N;
    std::vector<double> weighs(N+1,h);
    weighs[0] = h/2;
    weighs[N] = h/2;
    return weighs; 
  }
  virtual std::vector<double> makeQuadPnts(double a,double b)
  {  
    double h = (b-a)/N;
    std::vector<double> xp(N+1,0.0); // number of points equispaced
    double xi = a;
    std::generate(xp.begin()+1,xp.end(),[&xi,h](){return xi=xi+h;});
    return xp;
  }
  double operator()(std::function<double (double)> funToInt,double a,double b)
  {
    // Divide the interval [a,b] in subintervals and obtain the quadrature points:
    std::vector<double> w_ = this->makeWeights(a,b);
    std::vector<double> qp_    = this->makeQuadPnts(a,b);
    
    // Evaluate function in the quadrature points:
    std::vector<double> fxi(N+1);
    std::transform(qp_.begin(),qp_.end(),fxi.begin(),funToInt);

    // Return the inner product:
    return std::inner_product(w_.begin(),w_.end(),fxi.begin(),0.0);
  }
}; //END TRAPZ

template<int N>
class MidPointQuadrature
{
public:

  virtual std::vector<double> makeWeights(double a,double b)
  {
   double h= (b-a)/N;
   return std::vector<double>(N,h);
    
  }
  virtual std::vector<double> makeQuadPnts(double a,double b)
  {
    // Equispaced interval
    double h = (b-a)/N;
    std::vector<double> pnts(N,0.0); pnts[0] = h/2;
    double xi = a+h/2;
    std::generate(pnts.begin()+1,pnts.end(),[&xi,h](){return xi=xi+h;});
    return pnts; 
  }
  double operator()(std::function<double (double)> funToInt,double a,double b)
  {
      // Divide the interval [a,b] in N subintervals and obtain the quadrature points:
    std::vector<double> w_ = makeWeights(a,b);
    std::vector<double> qp_    = makeQuadPnts(a,b);

    // Evaluate function in the quadrature points:
    std::vector<double> fxi(N);
    std::transform(qp_.begin(),qp_.end(),fxi.begin(),funToInt);

    // Return the inner product:
    return std::inner_product(w_.begin(),w_.end(),fxi.begin(),0.0);  
  }
}; //end MIDPOINT-QUAD
  

template<int N>
class GaussLegendreQuadrature
{
  // In this class we use boost to obtain the quadrature weights.
  
  public:
   
  virtual std::vector<double> makeWeights(double a,double b)
  {
    // Obtain the weights from BOOST:
    std::vector<double> abscissa = makeQuadPnts();
    std::vector<double> weights(abscissa.size(),0.0);
    
    for (unsigned i = 0; i < abscissa.size(); ++i)
      {
	x = abscissa[i];
	double p = boost::math::legendre_p_prime(N, x);
	result[i] = 2 / ((1 - x * x) * p * p);
      }
    return weights;
  }
  virtual std::vector<double> makeQuadPnts(double a,double b)
  {
    //auto points_ = this->GaussIntegrator.abscissa();
    std::vector<double> points_ = boost::math::legendre_p_zeros<double>(N);
    return points_;
  }
  double operator()(std::function<double (double)> funToInt,double a,double b)
  {
   std::vector<double> w_ = makeWeights(a,b);
   std::vector<double> qp_    = makeQuadPnts(a,b);

   // Evaluate function in the quadrature points:
   std::vector<double> fxi(N);
   std::transform(qp_.begin(),qp_.end(),fxi.begin(),funToInt);

   // Return the inner product:
   return std::inner_product(w_.begin(),w_.end(),fxi.begin(),0.0); 
  }
private:
  //boost::math::quadrature::gauss<double,N> GaussIntegrator;
};
  

template<template <int> class QuadType,int N>
class NumericalIntegration:
  public QuadType<N>
{
public:
 
  double operator() (std::function<double (double)> funToInt,double a, double b)
  {
    return QuadType<N>::operator()(funToInt,a,b);
  }
};

  
} //END NAMESPACE

#endif
